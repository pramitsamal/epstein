18.3 Sel&Modification via Supercompilation 319

schema learning the learning of schemata carrying out cognitive processes in more specialized,
context-dependent ways than the general MindAgents do. Eventually, once a CogPrime instance
becomes sufficiently complex and advanced, these cognitive schema may replace the MindAgents
altogether, leaving the system to operate almost entirely based on cognitive schemata.

In order to make the process of cognitive schema learning easier, we may provide a number
of elementary schemata embodying the basic cognitive processes contained in the MindAgents.
Of course, cognitive schemata need not use these they may embody entirely different cognitive
processes than the MindAgents. Eventually, we want the system to discover better ways of doing
things than anything even hinted at by its initial MindAgents. But for the initial phases or the
system’s schema learning, it will have a much easier time learning to use the basic cognitive
operations as the initial MindAgents, rather than inventing new ways of thinking from scratch!

For instance, we may provide elementary schemata corresponding to inference operations,
such as
schemes Deduction

Input InheritanceLink: X, Y
Output InheritanceLink

The inference MindAgents apply this rule in certain ways, designed to be reasonably effective
in a variety of situations. But there are certainly other ways of using the deduction rule, outside
of the basic control strategies embodied in the inference MindAgents. By learning schemata in-
volving the Deduction schema, the system can learn special, context-specific rules for combining
deduction with concept-formation, association-formation and other cognitive processes. And as
it gets smarter, it can then take these schemata involving the Deduction schema, and replace
it with a new schema that eg. contains a context-appropriate deduction formula.

Eventually, to support cognitive schema learning, we will want to cast the hard-wired MindA-
gents as cognitive schemata, so the system can see what is going on inside them. Pragmatically,
what this requires is coding versions of the MindAgents in Combo (see Chapter 21 of Part 2)
rather than C++, so they can be treated like any other cognitive schemata; or alternately, rep-
resenting them as declarative Atoms in the Atomspace. Figure 18.1 illustrates the possibility of
representing the PLN deduction rule in the Atomspace rather than as a hard-wired procedure
coded in C++.

But even prior to this kind of fully cognitively transparent implementation, the system can
still reason about its use of different mind dynamics by considering each MindAgent as a virtual
Procedure with a real SchemaNode attached to it. This can lead to some valuable learning, with
the obvious limitation that in this approach the system is thinking about its MindAgents as
black boxes rather than being equipped with full knowledge of their internals.

18.3 Self-Modification via Supercompilation

Now we turn to a very different form of advanced self-modification: supercompilation. Super-
compilation merely enables procedures to run much, much faster than they otherwise would.
This is in a sense weaker than self-modication methods that fundamentally create new algo-
rithms, but it shouldn’t be underestimated. A 50x speedup in some cognitive process can enable
that process to give much smarter answers, which can then elicit different behaviors from the
world or from other cognitive processes, thus resulting in a qualitatively different overall cog-
nitive dynamic.

HOUSE_OVERSIGHT_013235
