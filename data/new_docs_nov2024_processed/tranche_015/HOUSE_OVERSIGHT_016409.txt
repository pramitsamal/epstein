How do you teach computational thinking? In terms of how to do programming,
it’s an interesting question. Take nanotechnology. How did we achieve nanotechnology?
Answer: We took technology as we understand it on a large scale and we made it very
small. How to make a CPU chip on the atomic scale? Fundamentally, we use the same
architecture as the CPU chip we know and love. That isn’t the only approach one can
take. Looking at what simple programs can do suggests that you can take even simple
impoverished components and with the right compiler you can make them do interesting
things. We don’t do molecular-scale computing yet, because the ambient technology is
such that you’d have to spend a decade building it. But we’ve got the components that
are enough to make a universal computer. You might not know how to program with
those components, but by doing searches in the space of possible programs, you'd start to
amass building blocks, and you could then create a compiler for them. The surprising
thing is that impoverished stuff is capable of doing sophisticated things, and the
compilation step is not as gruesome as you might expect.

Just searching the computational universe and trying to find programs—building
blocks—that are interesting is a good approach. A more traditional engineering
approach—trying by pure thought to figure out how to build a universal computer—is a
harder row to hoe. That doesn’t mean it can’t be done, but my guess is that we’ll be able
to do some amazing things just by finding the components and searching the possible
programs we can make with them. Then it’s back to the question about connecting
human purposes to what is available from the system.

One question I’m interested in is, What will the world look like when most people
can write code? We had a transition, maybe five hundred years ago or so, when only
scribes and a small set of the population could read and write natural language. Today, a
small fraction of the population can write code. Most of the code they write is for
computers only. You don’t understand things by reading code. But there will come a
time when, as a result of things I’ve tried to do, the code is at a high enough level that it’s
a minimal description of what you’re trying to do. It will be a piece of code that’s
understandable to humans but also executable by the machines.

Coding is a form of expression, just as writing in a natural language is a form of
expression. To me, some simple pieces of code are poetic—they express ideas in a very
clean way. There’s an aesthetic aspect, much as there is to expression in a natural
language. One feature of code is that it’s immediately executable; it’s not like writing.
When you write something, somebody has to read it, and the brain that’s reading it has to
absorb the thoughts that came from the person who did the writing. Look at how
knowledge has been transmitted in the history of the world. At level zero, one form of
knowledge transmission is essentially genetic—that is, there’s an organism, and its
progeny has the same features that it had. Then there’s the kind of knowledge
transmission that happens with things like physiological recognition. A newborn creature
has some neural network with some random connections in it, and as the creature moves
around in the world, it starts recognizing kinds of objects and it learns that knowledge.

Then there’s the level that was the big achievement of our species, which is
natural language. The ability to represent knowledge abstractly enough that we can
communicate it brain to brain, so to speak. Arguably, natural language is our species’
most important invention. It’s what led, in many respects, to our civilization.

189

HOUSE_OVERSIGHT_016409
